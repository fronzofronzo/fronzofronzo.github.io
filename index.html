<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Presentazione tesi - Gabriele Fronzoni</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/league.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
		<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
	</head>
ƒ	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<div class="r-fit-text">
						<p>Dipartimento di Informatica - Scienza e Ingegneria</p>
					<p>Corso di Laurea in Ingegneria e Scienze Informatiche</p>
					<h2>Studio e Applicazione di Graph Convolutional Network per il denoising di mesh 3D</h2>
					<p>Presentata da: Gabriele Fronzoni </p>
					<p>Relatore: Prof. Damiana Lazzaro</p>
					<p>Sessione Unica</p>
					<p>Anno Accademico 2024/2025</p>
					</div>
				</section>
				<section>
					<img src="images/Dolphin_triangle_mesh-Photoroom.png">
					<h3>Obiettivi della tesi</h3>
					<ul class="r-fit-text">
						<li><div style="display: flex; align-items: center;"><b style="color: gold;">GCN-Denoiser</b> <i class="material-icons"style="font-size:36px">arrow_right_alt</i> denoising di mesh<div></li>
						<li ><div style="display: flex; align-items: center;">Implementazione processo di generazione dei dati<i class="material-icons"style="font-size:36px">arrow_right_alt</i> Python</div></li>
						<li >Studio e introduzione di <b style="color: gold;">modifiche migliorative</b></li>
					</ul>
				</section>
				<section>
					<h3 >MESH</h3>
						<p>Da cosa sono caratterizzate?</p>
						<div class="r-stack ">
							<img class="fragment current-visible" src="images/mesh.png">
							<div class="fragment " style="width: 100%;">
    						<div class="mesh-item" style="width: 33%;float: left;">
      							<p>Vertici </p>
      							<img width="150" src="images/vertices.png">
    						</div>
   						<div class="mesh-item" style="width: 33%; float: left;">
      					<p>Spigoli</p>
      						<img width="150" src="images/egdes.png">
    					</div>
    					<div class="mesh-item full" style="width: 33%; float: left;">
      					<p>Facce</p>
      					<img width="150" src="images/faces.png">
    					</div>
  						</div>
						</div>
						
				</section>
				<section>
					<h3>Mesh <i class="material-icons" style="font-size:36px">trending_flat</i> Grafo</h3>
					<div >
						<img width="70%" src="images/mesh_to_graph.jpg">
						<p>Facce <i class="material-icons" style="font-size:36px">trending_flat</i> Nodi</p>
						<p>Spigoli <i class="material-icons" style="font-size:36px">trending_flat</i> Archi</p>
					</div>
				</section>
				<section>
					<h3>Graph Convolutional Network</h3>
					<div class="r-stack">
						<img class="fragment current-visible" src="images/gcn-general.png" />
						<div class="fragment current-visible">
							<ul class="r-stretch">
								<li>Struttura dei dati:
									<ul>
										<li><b>CNN</b>: dati con struttura regolare</li>
										<li><b>GCN</b>: dati non strutturati rappresentabili come grafi</li>
									</ul>
								</li>
								<li>Operazione di convoluzione
									<ul>
										<li><b>CNN</b>: aggrega le informazioni dei vicini spaziali</li>
										<li><b>GCN</b>: aggregazione di informazioni dei nodi vicini nel grafo</li>
									</ul>
								</li>
							</ul>
						</div>
						<div class="fragment">
							<img  src="images/gcn-architecture.png">
							\[ H^{(l+1)}= \sigma(\tilde{A}H^{(l)}W^{(l)})\]
						</div>
					</div>
				</section>
				<section>
					<h3>GCN-Denoiser</h3>
					<div class="r-stack">
						<img class="fragment fade-out" src="images/gcn-pipeline.png">
						<div class="fragment ">
							<ol>
								<li><div style="display: flex; align-items: center; gap: 10px;">Generazione di <b style="color: gold;">patch</b> locali per ogni faccia<img src="images/local_patch-removebg-preview.png" width="100"></div></li>
								<li><div style="display: flex; align-items: center; gap: 10px;">Costruzione del <b style="color: gold;">grafo</b> per ogni patch<img src="images/local_graph-removebg-preview.png" width="100"></div></li>
								<li><div style="display: flex; align-items: center; gap: 10px;">Utilizzo dei dati di input per <b style="color: gold;">predizione</b> delle normali </div></li>
								<li><b style="color: gold;">Aggiornamento</b> dei vertici usando le normali predette</li>
							</ol>
						</div>
					</div>
				</section>
				<section>
					<h3>GCN-Denoiser</h3>
					<pre><code data-line-numbers="3|6-7|10-15">
						def: training_gcns(K, NumEpochs):
							GCN = [GCN_1, ..., GCN_k]
							opt_function = [opt_1, ..., opt_k]
							loss = MSE(n, n_gt)
							for epoch in range(NumEpochs):
								for each batch in TrainingSet:
									n_curr = n_noise
									loss_t = 0
									for i in range(K):
										G = build_graph(n_curr)
										n_pred = GCN[i].forward(G)
										loss_s = loss(n_pred, n_gt)
										loss_t += loss_s
										n_curr = n_pred
									for i in range(K):
										opt_function[i].zero_grad()
									loss_t.backward()
									for i in range(K):
										opt_function[i].step()
								eval_model()
								print_metrics()
					</code></pre>
				</section>
				<section>
					<h3>Selezione delle patch</h3>
					<div class="r-stack">
						<div class="fragment current-visible">
							Per ogni faccia della mesh viene generata una patch locale, che comprende un insieme di facce vicine...
						</div>
						<div class="fragment current-visible">
							<p>...ma come vengono scelte le facce? </p>
						</div>
						<div class="fragment current-visible">
							
							\[
								\underset{f_j \in p_i}{\forall} \: \underset{v_k \in f_j}{\exists}\quad ||v_k - c_i|| < r; \, r = k\,\bar{a}^{\frac{1}{2}}_i
							\]
						</div>
					</div>
				</section>
				<section>
					<h3>Features</h3>
					<div>
							<p>Per ogni faccia che appartiene alla patch, si indicano:</p>
							<ul>
								<li><b style="color: gold;">Centroide</b> della faccia </li>
								<li><b style="color: gold;">Normale</b> alla faccia </li>
								<li><b style="color: gold;">Area</b> della faccia </li>
								<li><b style="color: gold;">Numero dei vicini </b>della faccia</li>
								<li><b style="color: gold;">Vertici</b> della faccia</li>
							</ul>
							<p><i>Tutti gli attributi vengono normalizzati</i></p>
						</div>
				</section>
				<section>
					<h3>Architettura della rete</h3>
					<div class="r-stack">
						<div class="fragment current-visible">
							<img src="images/network-architecture.png" width="75%"/>
							<p><b style="color: gold;">EdgeConv</b>:
								$
								F^i_{l+1} = \underset{j:(i,j) \in E_l }{\Psi}\,h^l_{\Theta}\,(F^i_l, F^j_l)
							$</p>
						</div>
						<div class="fragment">
							<p>La convoluzione non è solo statica...</p>
							<p class="fragment">... ma anche dinamica</p>
							<p class="fragment">Il grafo viene ricostruito in maniera dinamica usando l'algoritmo <b style="color: gold;">K-nearest-neighbors (KNN)</b>
							\[
								\mathcal{N}_k(f_i) = \underset{S \subset \mathcal{F}, |S|=k}{\text{argmin}} \sum_{f_j \in S} d(f_i, f_j)
							\]</p>
						</div>
					</div>
				</section>
				<section>
					<h3>Training</h3>
					<div class="r-stack">
						<img class="fragment current-visible" width="70%" src="images/training_set-Photoroom.png">
						<img class="fragment current-visible" src="images/noise.png">
						<div class="fragment current-visible">
							Misura di errore: <b style="color: gold;">Mean Squared Error (MSE)</b>:
							\[
								MSE = \frac{1}{n}\sum_{i=1}^{n}(y_i - \hat{y}_i)^2
							\]
						</div>
					</div>
				</section>
				<section>
 					<h3>Denoising</h3>
  					<p class="fragment">Prevede due fasi:</p>
						<div class="fragment ">
							<p style="color: gold;"> 1. Raffinamento delle normali</p>

							<div class="r-fit-text">
								\[
									\begin{aligned}
									\dot n_i &= \operatorname{normalize}\Big(  \sum_{f_j\in\Omega_i} a_j W_s(\|c_j-c_i\|) W_r(\|\hat n_j-\hat n_i\|)\,\hat n_j
									\Big)
									\end{aligned}
								\]
							</div>
							<p class="fragment"> Perché? <i class="material-icons" style="font-size:36px">trending_flat</i> regolarizzare le normali e evitare discontinuità locali</p>
					</div>
				</section>
				<section>
					<h3>Denoising</h3>
					<div >
							<p style="color: gold;">2. Aggiornamento dei vertici</p>
							<div class="r-fit-text">
								\[
									v^{k+1}_i = v_i^k + \frac{1}{3|\Omega^{'}_i|} \sum_{f_j \in \Omega^{'}_i} \sum_{e_{ij} \in \partial f_j} n_j^g \, [ n_j^g \cdot (v_j^k - v_i^k)]
								\]
							</div>
							<img src="images/vertex_updating.png" width="50%"/>
					</div>
				</section>
				<section>
					<h3>Modifiche alla rete</h3>
					<p>Si introducono due nuove features</p>
					<div class="r-stack">
						<div class="fragment">
							<p>$\alpha^n$: <b style="color: gold;">angolo di intensità del rumore</b></p>
							\[ \alpha^n = \text{acos}(n_i \cdot n_i^M)\]
							<p class="fragment">Perche? <i class="material-icons" style="font-size:35px">trending_flat</i> La rete originale non era in grado di ricostruire una superficie se coperta da rumore ad alta intensità</p>
							
						</div>
					</div>
				</section>
				<section>
					<h3>Modifiche alla rete</h3>
					<div>
						<p>$\alpha^g$: <b style="color: gold;">angolo delle caratteristiche geometriche</b></p>
						\[ \alpha^g_i = \max_{f_j \in \mathbb{P}^2_i}\,\max_{f_l \in \mathbb{P}^2_i}\, \text{acos}(n_j^M \cdot n_l^M).\]
						<p class="fragment">Perche? <i class="material-icons" style="font-size:35px">trending_flat</i> La rete originale assume che la natura del rumore e delle caratteristiche geometriche sia diversa</p>
						
					</div>
				</section>
				<section>
					<h3>Modifiche strutturali alla rete</h3>
					<p>La struttura dell'input cambia...</p>
					<p class="fragment">...quindi cambia anche la struttura della rete!</p>
					<ul class="fragment">
						<li>Aggiunta di un layer di <b style="color: gold;">Dynamic EdgeConv</b></li>
						<li>Ottimizzazione iperparametri di <b style="color: gold;">batch size</b> e <b style="color: gold;">learning rate</b> mediante Optuna</li>
					</ul>
				</section>
				<section>
					<h3>Testing e risultati ottenuti</h3>
					<div class="r-stack">
						<img class="fragment current-visible" src="images/testing.png">

						<ul class="fragment current-visible r-fit-text">
							
							<li>$E_a = \frac{1}{N_f} \sum_{f_i^r \in F^r} \text{acos}(n_i^r \cdot \tilde{n}_i)$ (errore angolare medio)</li> 
							<li>$E_v = \frac{1}{N_vL_d} \sum_{v_i^r \in \tilde{V}_M} \underset{\tilde{v}_j \in \tilde{V}_M}{\min} ||v_i^r - \tilde{v}_j ||$ (Distanza di Hausdorff media normalizzata)</li>
						</ul>
						<div class="fragment current-visible">
							<p>Vediamo alcuni risultati...</p>
						</div>
						<img class="fragment current-visible" src="images/result_chinese_lion_models.png" width="80%">
						<img class="fragment current-visible" src="images/chinese_lion_error_plot.png" >
						<img class="fragment current-visible" src="images/result_sharp_sphere_models.png" width="80%">
						<img class="fragment current-visible" src="images/sharp_sphere_error_plot.png" >
						<img class="fragment current-visible" src="images/result_trim_star_models.png" width="80%">
						<img class="fragment current-visible" src="images/trim-star_error_plot.png" >
					</div>
				</section>
				<section>
					<h3>Testing e risultati ottenuti</h3>
					<p class="fragment">In cosa migliora?</p>
					<p class="fragment">Recupero della superficie con <b style="color: gold;">alti livelli</b> di rumore</p>
				</section>
				<section>
					<p>Grazie per l'attenzione</p>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX]
			});
		</script>
	</body>
</html>
