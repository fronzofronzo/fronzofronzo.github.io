<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Presentazione tesi - Gabriele Fronzoni</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/league.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
		<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h3>Studio e Applicazione di Graph Convolutional Network per il denoising di mesh 3D</h3>
					<p>Presentata da: Gabriele Fronzoni </p>
					<p>Relatore: Prof. Damiana Lazzaro</p>
				</section>
				<section>
					<img src="images/Dolphin_triangle_mesh-Photoroom.png">
					<h3>Obiettivi</h3>
					<ul class="r-fit-text">
						<li class="fragment">Studio della struttura delle mesh e loro rappresentazione</li>
						<li class="fragment">Studio delle <b style="color: gold;">Graph Convolutional Network</b> e applicazione di queste per operazioni su mesh</li>
						<li class="fragment">Studio approfondito della <b style="color: gold;">GCN-Denoiser</b> per il denoising di mesh</li>
						<li class="fragment">Implementazione della GCN-Denoiser (generazione dati, rete, allenamento) in Python</li>
						<li class="fragment">Analisi e implementazione di modifiche migliorative della rete</li>
					</ul>
				</section>
				<section>
					<h3 >MESH</h3>
						<p>Da cosa sono caratterizzate?</p>
						<div class="r-stack ">
							<img class="fragment current-visible" src="images/mesh.png">
							<div class="fragment current-visible" style="width: 100%;">
    						<div class="mesh-item" style="width: 33%;float: left;">
      							<p>Vertici </p>
      							<img width="150" src="images/vertices.png">
    						</div>
   						<div class="mesh-item" style="width: 33%; float: left;">
      					<p>Spigoli</p>
      						<img width="150" src="images/egdes.png">
    					</div>
    					<div class="mesh-item full" style="width: 33%; float: left;">
      					<p>Facce</p>
      					<img width="150" src="images/faces.png">
    					</div>
  						</div>
						</div>
						
				</section>
				<section>
					<h3>Mesh <i class="material-icons" style="font-size:36px">trending_flat</i> Grafo</h3>
					<div class="fragment">
						<img width="70%" src="images/mesh_to_graph.jpg">
						<p>Facce <i class="material-icons" style="font-size:36px">trending_flat</i> Nodi</p>
						<p>Spigoli <i class="material-icons" style="font-size:36px">trending_flat</i> Archi</p>
					</div>
				</section>
				<section>
					<h3>Graph Convolutional Network</h3>
					<div class="r-stack">
						<img class="fragment current-visible" src="images/gcn-general.png" />
						<div class="fragment current-visible">
							<ol>
								<li>Input Layer</li>
								<li>Hidden Layers (Grah convolutional layers, Activaction functions, Pooling Layers)</li>
								<li>Output Layer</li>
								<li>Fully Connected Layers</li>
							</ol>
						</div>
						<div class="fragment">
							<img  src="images/gcn-architecture.png">
							\[ H^{(l+1)}= \sigma(\tilde{A}H^{(l)}W^{(l)})\]
						</div>
					</div>
				</section>
				<section>
					<h3>GCN-Denoiser</h3>
					<div class="r-stack">
						<img class="fragment current-visible" src="images/gcn-pipeline.png">
						<div class="fragment current-visible">
							<ol>
								<li><div style="display: flex; align-items: center; gap: 10px;">Generazione di <b style="color: gold;">patch</b> locali per ogni faccia<img src="images/local_patch-removebg-preview.png" width="100"></div></li>
								<li><div style="display: flex; align-items: center; gap: 10px;">Costruzione del <b style="color: gold;">grafo</b> per ogni patch<img src="images/local_graph-removebg-preview.png" width="100"></div></li>
								<li><div style="display: flex; align-items: center; gap: 10px;">Utilizzo dei dati di input per <b style="color: gold;">predizione</b> delle normali </div></li>
								<li><b style="color: gold;">Aggiornamento</b> dei vertici usando le normali predette</li>
							</ol>
						</div>
					</div>
				</section>
				<section>
					<h3>Selezione delle patch</h3>
					<div class="r-stack">
						<div class="fragment current-visible">
							Per ogni faccia della mesh viene generata una patch locale, che comprende un insieme di facce vicine...
						</div>
						<div class="fragment current-visible">
							<p>...ma come vengono scelte le facce? </p>
						</div>
						<div class="fragment current-visible">
							
							\[
								\underset{f_j \in p_i}{\forall} \: \underset{v_k \in f_j}{\exists}\quad ||v_k - c_i|| < r; \, r = k\,\bar{a}^{\frac{1}{2}}_i
							\]
						</div>
						<div class="fragment">
							<p>Per ogni faccia che appartiene alla patch, si indicano:</p>
							<ul>
								<li><b style="color: gold;">Centroide</b> della faccia </li>
								<li><b style="color: gold;">Normale</b> alla faccia </li>
								<li><b style="color: gold;">Area</b> della faccia </li>
								<li><b style="color: gold;">Numero dei vicini </b>della faccia</li>
								<li><b style="color: gold;">Vertici</b> della faccia</li>
							</ul>
							<p><i>Tutti gli attributi vengono normalizzati</i></p>
						</div>
					</div>
				</section>
				<section>
					<h3>Architettura della rete</h3>
					<div class="r-stack">
						<img class="fragment current-visible" src="images/network-architecture.png"/>
						<div class="fragment current-visible">
							L'operazione di convoluzione EdgeConv è definita come:
							\[
								F^i_{l+1} = \underset{j:(i,j) \in E_l }{\Psi}\,h^l_{\Theta}\,(F^i_l, F^j_l),
							\]
						</div>
						<div class="fragment">
							<p>La convoluzione non è solo statica...</p>
							<p class="fragment">... ma anche dinamica</p>
							<p class="fragment">Il grafo viene ricostruito in maniera dinamica usando l'algoritmo <b style="color: gold;">K-nearest-neighbors (KNN)</b>
							\[
								\mathcal{N}_k(f_i) = \underset{S \subset \mathcal{F}, |S|=k}{\text{argmin}} \sum_{f_j \in S} d(f_i, f_j)
							\]</p>
						</div>
					</div>
				</section>
				<section>
					<h3>Training</h3>
					<div class="r-stack">
						<img class="fragment current-visible" width="70%" src="images/training_set-Photoroom.png">
						<img class="fragment current-visible" src="images/noise.png">
					</div>
				</section>
				<section>
 					<h3>Denoising</h3>
  					<p class="fragment">Prevede due fasi:</p>
						<div class="fragment ">
							<p style="color: gold;"> 1. Raffinamento delle normali</p>

							<div class="r-fit-text">
								\[
									\begin{aligned}
									\dot n_i &= \operatorname{normalize}\Big(  \sum_{f_j\in\Omega_i} a_j W_s(\|c_j-c_i\|) W_r(\|\hat n_j-\hat n_i\|)\,\hat n_j
									\Big)
									\end{aligned}
								\]
							</div>
							<p class="fragment"> Perché? <i class="material-icons" style="font-size:36px">trending_flat</i> regolarizzare le normali e evitare discontinuità locali</p>
					</div>
				</section>
				<section>
					<h3>Denoising</h3>
					<div >
							<p style="color: gold;">2. Aggiornamento dei vertici</p>
							<div class="r-fit-text">
								\[
									v^{k+1}_i = v_i^k + \frac{1}{3|\Omega^{'}_i|} \sum_{f_j \in \Omega^{'}_i} \sum_{e_{ij} \in \partial f_j} n_j^g \, [ n_j^g \cdot (v_j^k - v_i^k)]
								\]
							</div>
							<img src="images/vertex_updating.png" width="50%"/>
					</div>
				</section>
				<section>
					<h3>Modifiche alla rete</h3>
					<p>Si introducono due nuove features</p>
					<div class="r-stack">
						<div class="fragment">
							<p>$\alpha^n$: <b style="color: gold;">angolo di intensità del rumore</b></p>
							\[ \alpha^n = \text{acos}(n_i \cdot n_i^M)\]
							<p class="fragment">Perche? <i class="material-icons" style="font-size:35px">trending_flat</i> La rete originale non era in grado di ricostruire una superficie se coperta da rumore ad alta intensità</p>
							
						</div>
					</div>
				</section>
				<section>
					<h3>Modifiche alla rete</h3>
					<div>
						<p>$\alpha^g$: <b style="color: gold;">angolo delle carattaristiche geometriche</b></p>
						\[ \alpha^g_i = \max_{f_j \in \mathbb{P}^2_i}\,\max_{f_l \in \mathbb{P}^2_i}\, \text{acos}(n_j^M \cdot n_l^M).\]
						<p class="fragment">Perche? <i class="material-icons" style="font-size:35px">trending_flat</i> La rete originale assume che la natura del rumore e delle caratteristiche geometriche sia diversa</p>
						
					</div>
				</section>
				<section>
					<h3>Testing e risultati ottenuti</h3>
					<div class="r-stack">
						<img class="fragment current-visible" src="images/testing.png">
						<ul class="fragment current-visible">
							<li>Per entrambi i modelli, si è considerata la versione migliore ottenuta dopo 25 epoche di training;</li>
							<li>I modelli sono stati testati su tre mesh, per ognuna delle quali si è generata una versione con rumore da 0.1 a 0.5;</li>
							<li>Per la rete con le modifiche è stato effettuato uno studio per l'ottimizzazione degli iperparametri;</li>
							<li>Come misure di errore sono stati utilizzati l'errore medio delle normali ($E_a$) e la distanza di Hausdorff media normalizzata ($E_v$)</li>
						</ul>
						<img class="fragment current-visible" src="images/result_chinese_lion_models.png" width="80%">
						<img class="fragment current-visible" src="images/chinese_lion_error_plot.png" >
						<img class="fragment current-visible" src="images/result_sharp_sphere_models.png" width="80%">
						<img class="fragment current-visible" src="images/sharp_sphere_error_plot.png" >
						<img class="fragment current-visible" src="images/result_trim_star_models.png" width="80%">
						<img class="fragment current-visible" src="images/trim-star_error_plot.png" >
					</div>
				</section>
				<section>
					<p>Grazie per l'attenzione</p>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX]
			});
		</script>
	</body>
</html>
